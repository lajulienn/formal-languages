# Условие задачи
 Даны α, буква x и натуральное число k. Вывести длину кратчайшего слова из
языка L, содержащего подслово x^k.

# Алгоритм работы
 Алгоритм похож на алгоритм вычисления арифметического выражения на стековом калькуляторе. Обработка регулярного выражения начинается с его начала. 
Заведем стек, в который будем складывать экземпляры такого класса:  

    RegularExpression {  
       int subword_len // минимальная длина слова, содержащего x в степени >=k;  
       int[k] suffix_len; // массив минимальных длин слов, содержащих x^i в качестве суффикса, где i - индекс соответствующего элемента массива.  
       int[k] prefix_len // массив минимальных длин слов, содержащих x^i в качестве префикса, где i - индекс соответствующего элемента массива.  
       int[k] min_len // длина минимального слова в языке.  
    }  

Итак, k-й шаг:  
Считываем из входной строки symbol.  
- Если `symbol` - символ алфавита, то кладем в стек `RegularExpression` с соответствующе заполненными полями.  
- Если `symbol = '*'`, continue, тк данная операция не влияет на длину минимального слова с подсловом x^k. Однако, если у нас есть слово, состоящее из x, это увеличивает его длину. Длина мин. слова --- 0.  
- Если `symbol = '+'`, извлекаем из стека 2 элемента `reg1` и `reg2`, возвращаем обратно `(min(reg1.subword_len, reg2.subword_len), min(reg1.suffix_len, reg2.suffix_len) поэлементно, min(reg1.prefix_len, reg2.prefix_len)) поэлементно, min(reg1.min_len, reg2.min_len)`.  
- Если `symbol = '.'`, извлекаем из стека 2 элемента `reg1` и `reg2`, возвращаем обратно `(min(reg1.subword_len + reg2.min_len, reg1.min_len + reg2.subword_len), reg1.suffix_len + reg2.min_len, reg1.min_len + reg2.suffix_len, reg1.min_len + reg2.min_len))` (плюс обрабока, 
если слово может состоять только из x).  

Если во время исполнения алгоритма окажется, что не хватает аргументов для операции или что в конце осталось больше одного элемента на стеке, выводим сообщение об ошибке.  
Также заводим специальную величину `INF` для `subword_len`, когда в алфавите, задаваемом регулярным выражением на каком-то шаге, нет слова с нужным подсловом. Если по окончании работы алгоритма у объекта на стеке `subword_len == INF`, выводим `INF`, так как нужного слова не существует. Если все хорошо,и на стеке остался 1 элемент, выводим `subword_len`.
